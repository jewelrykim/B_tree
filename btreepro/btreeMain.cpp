#include<stdio.h>
#include<malloc.h>
#pragma warning(disable:4996)
#define membernum 5

int a;

struct datanode {
	int node[membernum];
	datanode* cpointer[membernum + 1];
	datanode* ppointer;
	bool leaf;
	int count;
};
struct bignode {
	int node[membernum + 1];
	datanode* cpointer[membernum + 2];
	datanode* ppointer;
};
typedef struct datanode* nodePtr;
typedef struct bignode* bignodePtr;
void find_node() {

}
void init_node(nodePtr initnode) {
	for (int i = 0; i < membernum; i++) {
		initnode->node[i] = NULL;
		initnode->cpointer[i] = NULL;
		initnode->ppointer = NULL;
	}
	initnode->leaf = 0;
	initnode->count = 0;
}
void make_node(int inputdata) {
	nodePtr newnode = (nodePtr)malloc(sizeof(datanode));
}

void add_node() {

};
void search_data(nodePtr currentnode) { //특정 데이터를 찾는 함수
	printf("%d", currentnode->node[0]);
}
void print_data(nodePtr currentnode) {
	for (int i = 0; i < membernum; i++) {
		printf(" %d  ", currentnode->node[i]);
	}
	printf("\n");
}
int data_count(nodePtr currentnode) {	//노드에 데이터 숫자
	int count = 0;
	for (int i = 0; i < membernum; i++) {
		if (currentnode->node[i] == NULL) {
			return i;
		}
	}
	return membernum;
}
int search_point(nodePtr currentnode,int targetdata) { //데이터가 들어갈 위치
	for (int i = 0; i < membernum - 1; i++) {
		if (currentnode->node[i] > targetdata) {
			return i;
		}
	}
	return membernum - 1;
}
void inputbignode(nodePtr currentnode, bignodePtr bignodetemp, int location, int targetdata) { // big노드에 추가된 데이터와 기존 데이터를 삽입하는것
	if (location == 0) {
		bignodetemp->node[0] = targetdata;
		bignodetemp->ppointer = currentnode->ppointer;
		for (int i = 0; i < membernum ; i++) {
			bignodetemp->node[i + 1] = currentnode->node[i];
			bignodetemp->cpointer[i + 1] = currentnode->cpointer[i];
		}
	}
	else if (location == membernum - 1) {
		bignodetemp->node[membernum] = targetdata;
		bignodetemp->ppointer = currentnode->ppointer;
		for (int i = 0; i < membernum - 1; i++) {
			bignodetemp->node[i ] = currentnode->node[i];
			bignodetemp->cpointer[i] = currentnode->cpointer[i];
		}
	}
	else {
		for (int i = 0; i < location; i++) {
			bignodetemp->node[i] = currentnode->node[i];
			bignodetemp->cpointer[i] = currentnode->cpointer[i];
		}
		bignodetemp->node[location] = currentnode->node[location];
		bignodetemp->cpointer[location] = currentnode->cpointer[location];
		bignodetemp->ppointer= currentnode->ppointer;
		for (int i = location+1; i < membernum+1; i++) {
			bignodetemp->node[i] = currentnode->node[i-1];
			bignodetemp->cpointer[i] = currentnode->cpointer[i-1];
		}
	}
	init_node(currentnode);
}

void replace_node(nodePtr currentnode, int startpoint ,int targetdata) { //노드를 뒤로 한칸씩 미룬다.
	for (int i = data_count(currentnode) - 1; i > startpoint - 1; i--)
	{
		currentnode->node[i + 1] = currentnode->node[i];
	}
	currentnode->node[startpoint] = targetdata;
}

void branchnode(nodePtr currentnode, int targetdata) {	//노드가 꽉 차있는 상태에서 삽입
	//루트인 경우와 루트가 아닌경우
	bignodePtr bignodetemp = (bignodePtr)malloc(sizeof(bignodePtr));
	nodePtr newnode = (nodePtr)malloc(sizeof(datanode));
	nodePtr newrootnode = (nodePtr)malloc(sizeof(datanode));

	init_node(newnode);
	init_node(newrootnode);

	inputbignode(currentnode, bignodetemp, search_point(currentnode, targetdata), targetdata);
	for (int i = 0; i < membernum / 2; i++) {
		currentnode->node[i] = bignodetemp->node[i];
		currentnode->cpointer[i] = bignodetemp->cpointer[i];
	}
	currentnode->ppointer = newrootnode;

	newrootnode->node[0] = bignodetemp->node[membernum / 2];
	newrootnode->cpointer[0] = currentnode;
	newrootnode->cpointer[1] = newnode;

	for (int i = (membernum / 2) + 1, int j = 0; i < membernum + 1; i++, j++) {
		newnode->node[i] = bignodetemp->node[i];
		newnode->cpointer[i] = bignodetemp->cpointer[i];
	}
	newnode->ppointer = newrootnode;

	if (bignodetemp->ppointer == NULL){//끝 새로운 루트
	}
	else if (bignodetemp->ppointer->count < membernum-1) { //부모노드에 자리가 있다 newroot를 부모노드에 넣는다.
		replace_node(bignodetemp->ppointer, search_point(bignodetemp->ppointer, bignodetemp->node[0]), newrootnode->node[0]);	//빅노드의 부모에 newroot노드의 데이터를 삽입한다.
		currentnode->ppointer = bignodetemp->ppointer; //부모노드를 bignode의 부모로 바꾼다.
		newnode->ppointer = bignodetemp->ppointer;
	}
	else {//부모노드에 자리가 없다.
		branchnode(bignodetemp->ppointer, newrootnode->node[0]); //bignode의 부모와 newroot노드를 합친다.

	}
}
//////////////////////////////////////////////////////
void insert_point(nodePtr currentnode, int targetdata) {//데이터를 삽입하는 노드
	for (int i = 0; i < membernum-1; i++) {
		if (currentnode->node[i] > targetdata) {	// 해당 데이터보다 작다
			if (currentnode->leaf == true) {
				if (currentnode->count < membernum) {	//노드에 자리가 있다
					currentnode->node[ currentnode->count - 1] = targetdata;
				}
				else {	//노드에 자리가 없다.
					branchnode(currentnode,targetdata);
				}
			}

			if (currentnode->cpointer[i] == NULL) {	//앞 포인터가 비어있다 
				
			}
			else {	//가장 앞 포인터가 비어있지 않다. 자식 노드가 존재 한다.
				//search_point(currentnode->cpointer[i], targetdata); // 재귀로 위치를 찾는다.
			}
			break;
		}
		else {//현재 노드의 앞 데이터 보다 찾는 데이터가 큰경우
			if (currentnode->node[i + 1] == NULL) {	//현재 노드의 뒤 데이터가 비어있는경우
				if (currentnode->cpointer[i+1] == NULL) {	//현재 노드의 뒤 포인터가 비어있는 경우 (리프노드)
					currentnode->node[i + 1] = targetdata;	//현재노드의 뒤 쪽 데이터에 삽입
				}
				else { //현재 노드의 뒤 포인터가 존재 (자식 노드가 있다)
				//	search_point(currentnode->cpointer[i + 1], targetdata); //다시한번 inseart_data로 들어간다 (재귀)
				}
				break;
			}
		}
	}
}
/*
void search_point(nodePtr currentnode, int targetdata) {//데이터를 삽입하는 노드
for (int i = 0; i < membernum-1; i++) {
if (currentnode->node[i] > targetdata) {	// 해당 데이터보다 작다
if (currentnode->pointer[i] == NULL) {	//앞 포인터가 비어있다
if (data_count(currentnode) == membernum ) {	//현재 노드가 가득 찼다
//재배열
}
else {	//현재 노드에 빈 공간이 있다.
replace_node(currentnode, i);
currentnode->node[i] = targetdata;
}
}
else {	//가장 앞 포인터가 비어있지 않다. 자식 노드가 존재 한다.
search_point(currentnode->pointer[i], targetdata); // 재귀로 위치를 찾는다.
}
break;
}
else {//현재 노드의 앞 데이터 보다 찾는 데이터가 큰경우
if (currentnode->node[i + 1] == NULL) {	//현재 노드의 뒤 데이터가 비어있는경우
if (currentnode->pointer[i+1] == NULL) {	//현재 노드의 뒤 포인터가 비어있는 경우 (리프노드)
currentnode->node[i + 1] = targetdata;	//현재노드의 뒤 쪽 데이터에 삽입
}
else { //현재 노드의 뒤 포인터가 존재 (자식 노드가 있다)
search_point(currentnode->pointer[i + 1], targetdata); //다시한번 inseart_data로 들어간다 (재귀)
}
break;
}
}
}
}
*/
void inseart_data(nodePtr currentnode) {
	printf("입력하세요\n");
	scanf("%d", &a);
	//search_point(currentnode, a);
}
int memu() {
	printf("메뉴 \n 1.검색 2.입력 3.삭제 4.전체표시 0.종료\n");
	scanf("%d", &a);
	return a;
}
void main() {
	nodePtr initnode = (nodePtr)malloc(sizeof(datanode));
	printf("입력하세요\n");
	scanf("%d", &a);
	init_node(initnode);
	initnode->node[0] = a;
	while (memu() != 0){
		switch (a)
		{
		case 1:
			//search_data();
			break;
		case 2:
			inseart_data(initnode);
			break;
		case 3:
			break;
		case 4:
			print_data(initnode);
			break;
		default:
			break;
		}
	}
}